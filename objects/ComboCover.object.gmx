<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>_Cover</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw line of sight on the surface
if(instance_exists(Player) &amp;&amp; surface_exists(surf)) {
    surface_set_target(surf);
    draw_clear_alpha(c_black, 0);
    draw_set_color(c_black);
    var inst = instance_find(Player, 0);
    with(Wall) {
        if(visible) {
            ///From top edge
            var m = 0, dist, dest;
            dist[1] = 0;
            dest[1] = 0;
            if((inst.y - inst.sprite_yoffset) != bbox_top) {
                m = (bbox_left - inst.x) / (bbox_top - (inst.y - inst.sprite_yoffset));
            } else {
                m = 0;
            }
            if((inst.y - inst.sprite_yoffset) &lt; bbox_top) {
                dist[0] = (room_height - bbox_top) * m;
                dest[0] = room_height;
            } else if((inst.y - inst.sprite_yoffset) &gt; bbox_top) {
                dist[0] = bbox_top * -m;
                dest[0] = 0;
            } else {
                dist[0] = 0;
                dest[0] = bbox_top;
            }
            draw_triangle(bbox_left, bbox_top, (bbox_right + 1), bbox_top, bbox_left + dist[0], dest[0], false);
            if((inst.y - inst.sprite_yoffset) != bbox_top) {
                m = ((bbox_right + 1) - inst.x) / (bbox_top - (inst.y - inst.sprite_yoffset));
            } else {
                m = 0;
            }
            if((inst.y - inst.sprite_yoffset) &lt; bbox_top) {
                dist[1] = (room_height - bbox_top) * m;
                dest[1] = room_height;
            } else if((inst.y - inst.sprite_yoffset) &gt; bbox_top) {
                dist[1] = bbox_top * -m;
                dest[1] = 0;
            } else {
                dist[1] = 0;
                dest[1] = bbox_top;
            }
            draw_triangle((bbox_right + 1) + dist[1], dest[1], (bbox_right + 1), bbox_top, bbox_left + dist[0], dest[0], false);
            
            //From bottom edge
            if((inst.y - inst.sprite_yoffset) != (bbox_bottom + 1)) {
                m = (bbox_left - inst.x) / ((bbox_bottom + 1) - (inst.y - inst.sprite_yoffset));
            } else {
                m = 0;
            }
            if((inst.y - inst.sprite_yoffset) &lt; (bbox_bottom + 1)) {
                dist[0] = (room_height - (bbox_bottom + 1)) * m;
                dest[0] = room_height;
            } else if((inst.y - inst.sprite_yoffset) &gt; (bbox_bottom + 1)) {
                dist[0] = (bbox_bottom + 1) * -m;
                dest[0] = 0;
            } else {
                dist[0] = 0;
                dest[0] = (bbox_bottom + 1);
            }
            draw_triangle(bbox_left, (bbox_bottom + 1), (bbox_right + 1), (bbox_bottom + 1), bbox_left + dist[0], dest[0], false);
            if((inst.y - inst.sprite_yoffset) != (bbox_bottom + 1)) {
                m = ((bbox_right + 1) - inst.x) / ((bbox_bottom + 1) - (inst.y - inst.sprite_yoffset));
            } else {
                m = 0;
            }
            if((inst.y - inst.sprite_yoffset) &lt; (bbox_bottom + 1)) {
                dist[1] = (room_height - (bbox_bottom + 1)) * m;
                dest[1] = room_height;
            } else if((inst.y - inst.sprite_yoffset) &gt; (bbox_bottom + 1)) {
                dist[1] = (bbox_bottom + 1) * -m;
                dest[1] = 0;
            } else {
                dist[1] = 0;
                dest[1] = (bbox_bottom + 1);
            }
            draw_triangle((bbox_right + 1) + dist[1], dest[1], (bbox_right + 1), (bbox_bottom + 1), bbox_left + dist[0], dest[0], false);
            
            //From left side
            if(inst.x != bbox_left) {
                m = (bbox_top - (inst.y - inst.sprite_yoffset)) / (bbox_left - inst.x)
            } else {
                m = 0;
            }
            if(inst.x &lt; bbox_left) {
                dist[0] = (room_width - bbox_left) * m;
                dest[0] = room_width;
            } else if(inst.x &gt; bbox_left) {
                dist[0] = bbox_left * -m;
                dest[0] = 0;
            } else {
                dist[0] = 0;
                dest[0] = bbox_left;
            }
            draw_triangle(bbox_left, bbox_top, bbox_left, (bbox_bottom + 1), dest[0], bbox_top + dist[0], false);
            if(inst.x != bbox_left) {
                m = ((bbox_bottom + 1) - (inst.y - inst.sprite_yoffset)) / (bbox_left - inst.x);
            } else {
                m = 0;
            }
            if(inst.x &lt; bbox_left) {
                dist[1] = (room_width - bbox_left) * m;
                dest[1] = room_width;
            } else if(inst.x &gt; bbox_left) {
                dist[1] = bbox_left * -m;
                dest[1] = 0;
            } else {
                dist[1] = 0;
                dest[1] = bbox_left;
            }
            draw_triangle(dest[1], (bbox_bottom + 1) + dist[1], bbox_left, (bbox_bottom + 1), dest[0], bbox_top + dist[0], false);
            //From right side
            if(inst.x != (bbox_right + 1)) {
                m = (bbox_top - (inst.y - inst.sprite_yoffset)) / ((bbox_right + 1) - inst.x)
            } else {
                m = 0;
            }
            if(inst.x &lt; (bbox_right + 1)) {
                dist[0] = (room_width - (bbox_right + 1)) * m;
                dest[0] = room_width;
            } else if(inst.x &gt; (bbox_right + 1)) {
                dist[0] = (bbox_right + 1) * -m;
                dest[0] = 0;
            } else {
                dist[0] = 0;
                dest[0] = (bbox_right + 1);
            }
            draw_triangle((bbox_right + 1), bbox_top, (bbox_right + 1), (bbox_bottom + 1), dest[0], bbox_top + dist[0], false);
            if(inst.x != (bbox_right + 1)) {
                m = ((bbox_bottom + 1) - (inst.y - inst.sprite_yoffset)) / ((bbox_right + 1) - inst.x);
            } else {
                m = 0;
            }
            if(inst.x &lt; (bbox_right + 1)) {
                dist[1] = (room_width - (bbox_right + 1)) * m;
                dest[1] = room_width;
            } else if(inst.x &gt; (bbox_right + 1)) {
                dist[1] = (bbox_right + 1) * -m;
                dest[1] = 0;
            } else {
                dist[1] = 0;
                dest[1] = (bbox_right + 1);
            }
            draw_triangle(dest[1], (bbox_bottom + 1) + dist[1], (bbox_right + 1), (bbox_bottom + 1), dest[0], bbox_top + dist[0], false);
        }
    }
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw circles on surface
if(surface_exists(surf)) {
    var temp = surface_create(2048, 2048);
    surface_set_target(temp);
    draw_clear(c_black);
    draw_set_color(c_black);
    draw_set_blend_mode_ext(bm_inv_src_alpha, bm_inv_dest_alpha);
    
    draw_circle(Player.x, Player.y, 100, false);
    
    if(instance_exists(Lightbulb)) {
        with(Lightbulb) {
            if(lit) {
                draw_circle(x, y + 10, 200, false);
            }
        }
    }
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    surface_set_target(surf);
    draw_surface(temp, 0, 0);
    surface_reset_target();
    surface_free(temp);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
