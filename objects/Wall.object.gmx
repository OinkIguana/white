<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sWall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4</depth>
  <persistent>0</persistent>
  <parentName>_Terrain</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize
type = T_DIRT;
textureTiles[0, sprite_width / sprite_get_width(sprite_index) - 1] = -1;
textureTiles[1, sprite_height / sprite_get_height(sprite_index) - 1] = -1;
textureTiles[2, sprite_width / sprite_get_width(sprite_index) - 1] = -1;
textureTiles[3, sprite_height / sprite_get_height(sprite_index) - 1] = -1;
moved = false;
prev[3] = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for movement
if(y != prev[3] || x != prev[2] || image_yscale != prev[0] || image_xscale != prev[1]) {
    moved = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Record position
prev[3] = y;
prev[2] = x;
prev[1] = image_xscale;
prev[0] = image_yscale;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Melt when near fire
if(type == T_ICE) {
    if(Controller.colours[RED]) {
        var inst = instance_nearest(x, y, Torch);
        if(inst != noone) {
            if(distance_to_object(inst) &lt; 48) {
                if(inst.lit) {
                    image_alpha -= 0.02;
                    if(image_alpha &lt;= 0) {
                        instance_destroy();
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Choose textureTiles
var inst = noone;
if(y &gt; 0 &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 0); i++) {
        textureTiles[0, i] = -1;
        inst = collision_line(x + (i * sprite_get_width(sprite_index)), y - 1, x + ((i + 1) * sprite_get_width(sprite_index)) - 1, y - 1, _Terrain, false, true)
        if(inst == noone) { 
            if(type == T_STONE || type == T_DIRT || type == T_SNOW) {
                textureTiles[0, i] = irandom_range(0, 4);
            }
        } else if(type == T_STONE &amp;&amp; inst.object_index == Water) {
            textureTiles[0, i] = irandom_range(0, 4);
        }
    }
}

if(x &gt;= 0 &amp;&amp; x + sprite_width &lt; room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 1); i++) {
        textureTiles[1, i] = -1;
        inst = collision_line(x + sprite_width + 1, y + (i * sprite_get_height(sprite_index)), x + sprite_width + 1, y + ((i + 1) * sprite_get_height(sprite_index)) - 1, _Terrain, false, true)
        if(inst == noone) {
            if(type == T_STONE) {
                textureTiles[1, i] = irandom_range(0, 4);
            }
        } else if(type == T_STONE &amp;&amp; inst.object_index == Water){
            textureTiles[1, i] = irandom_range(0, 4);
        }
    }
}

if(y + sprite_height &lt; room_height &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 2); i++) {
        textureTiles[2, i] = -1;
        inst = collision_line(x + (i * sprite_get_width(sprite_index)), y + sprite_height + 1, x + ((i + 1) * sprite_get_width(sprite_index)) - 1, y + sprite_height + 1, _Terrain, false, true);
        if(inst == noone) {
            if(type == T_STONE) {
                textureTiles[2, i] = irandom_range(0, 4);
            }
        } else if(type == T_STONE &amp;&amp; inst.object_index == Water) {
            textureTiles[2, i] = irandom_range(0, 4);
        }
    }
}

if(x &gt; 0 &amp;&amp; x + sprite_width &lt;= room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 3); i++) {
        textureTiles[3, i] = -1;
        inst = collision_line(x - 1, y + (i * sprite_get_height(sprite_index)), x - 1, y + ((i + 1) * sprite_get_height(sprite_index)) - 1, _Terrain, false, true);
        if(inst == noone) {
            if(type == T_STONE) {
                textureTiles[3, i] = irandom_range(0, 4);
            }
        } else if(type == T_STONE &amp;&amp; inst.object_index == Water) {
            textureTiles[3, i] = irandom_range(0, 4);
        }
    }
}

if(type == T_ICE) {
    image_alpha = 0.8;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw self and choose colour
if(type == T_DIRT || type == T_WOOD) {
    if(Controller.colours[BROWN]) {
        image_blend = make_color_rgb(90, 60, 30);
    } else {
        image_blend = c_white;
    }
} else if(type == T_SAND) {
    if(Controller.colours[YELLOW]) {
        image_blend = make_color_rgb(255, 255, 200);;
    } else {
        image_blend = c_white;
    }
} else if(type == T_STONE) {
    if(Controller.colours[BLACK]) {
        image_blend = c_gray;
    }
} else if(type == T_ICE) {
    if(Controller.colours[BLUE]) {
        image_blend = make_color_rgb(200, 200, 220);
    }
}
if(webgl_enabled == true || os_browser == browser_not_a_browser) {
    draw_self();
} else {
    draw_set_color(image_blend);
    draw_rectangle(x, y, x + 16 * image_xscale - 1, y + 16 * image_yscale - 1, false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw grass and other textures
if(y &gt; 0 &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 0); i++) {
        if(textureTiles[0, i] != -1) {
            if(type == T_DIRT) {
                if(Controller.colours[GREEN]) {
                    draw_sprite(sGrass, textureTiles[0, i], x + i * sprite_get_width(sprite_index), y - sprite_get_height(sGrass));
                }
            } else if(type == T_STONE) {
                draw_sprite_ext(sCaveTexture, textureTiles[0, i], x + i * sprite_get_width(sprite_index), y - sprite_get_height(sCaveTexture), 1, 1, 0, image_blend, 1);
            } else if(type == T_SNOW) {
                draw_sprite(sSnowTexture, textureTiles[0, i], x + i * sprite_get_width(sprite_index), y - sprite_get_height(sSnowTexture));
            }
        }
    }
}

if(x &gt;= 0 &amp;&amp; x + sprite_width &lt; room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 1); i++) {
        if(textureTiles[1, i] != -1) {
            if(type == T_STONE) {
                draw_sprite_ext(sCaveTexture, textureTiles[1, i], x + sprite_width + sprite_get_height(sCaveTexture), y + i * sprite_get_width(sprite_index), 1, 1, 270, image_blend, 1);
            }
        }
    }
}

if(y + sprite_height &lt; room_height &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 2); i++) {
        if(textureTiles[2, i] != -1) {
            if(type == T_STONE) {
                draw_sprite_ext(sCaveTexture, textureTiles[2, i], x + (i + 1) * sprite_get_width(sprite_index), y + sprite_height + sprite_get_height(sCaveTexture), 1, 1, 180, image_blend, 1);
            }
        }
    }
}

if(x &gt; 0 &amp;&amp; x + sprite_width &lt;= room_width) {
    for(var i = 0; i &lt; array_length_2d(textureTiles, 3); i++) {
        if(textureTiles[3, i] != -1) {
            if(type == T_STONE) {
                draw_sprite_ext(sCaveTexture, textureTiles[3, i], x - sprite_get_height(sCaveTexture), y + (i + 1) * sprite_get_width(sprite_index), 1, 1, 90, image_blend, 1);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
